Instalações:

- Java (Development Kit) 10;
- Gradle (4.7), e Maven (3.5.3) (ambas, são ferramentas de build);
- IntelliJ, versão community (IDE);
- Wrapper (serve para corrigir problemas de incopatibilidade, de builds, tanto no gradle, quanto no maven).

Criando wrapper´s:

- Gradle: gradle wrapper (e para visualizar as informações: gradlew -v);
- Maven: mvn -N io.takari:maven:wrapper (e para visualizar as informações: mvnw -v);
- Uma pasta com os wrappers, não necessariamente com este nome, para cada uma das ferramentas, na pasta raiz, de quem chamou este comando, por exemplo o usuário x.

Obs.:

- Para configurar as variáveis de ambiente no Windows 10, do Java, Gradle, Wrapper:
	- Ir na parte de variáveis de sistema, do windows;
	- Criar uma nova variável de ambiente, na parte de variáveis de sistema (para que a mesma fique disponível há todos os usuários);
	- Dar o nome da variável (para a configuração do Java - JAVA_HOME, do Gradle - GRADLE_HOME, e Maven - MAVEN_HOME);
	- Indicar o endereço do diretório da variável de ambiente (por exemplo: C: ...);
	- Editar a váriavel path, adicionando a/s variáveis criadas (por exemplo: %JAVA_HOME%\bin);
	- Pronto, de Ok em todas as janelas, e as configurações estão concluídas.

- Para validar se as configurações foram realizadas, testar os comandos no terminal: 
	- Java: java -version;
	- Gradle: gradle -v;
	- Maven: mvn -v;

- Diferença, entre o Gradle, e o Maven: Gradle é uma ferramenta mais nova, é atualmente é a mais utilizada no mercado, esta ferramenta usa a linguagem de programação "Groovy". O Maven é uma ferramenta mais antiga, logo você pode usa-ló em aplicações Java legado (antigas), esta ferramenta é baseada em XML.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Criação de Projetos

- Para baixar as dependências do projeto, fomos até o site "https://start.spring.io/", escolhemos as opeções, e geramos o projeto;

- Ao definir o group (ou, grupo pertencente do projeto), inserimos o dominío ao contrário, por exemplo: globallabs.com.br > br.com.globallabs;

- Após o Download dos projetos (com as builds, Maven e Gradle), os importamos no intelliJ, onde o mesmo fará as dependências do projeto, automaticamente;

- Caso haja algum erro com Java, no projeto, mude a versão do Java, no arquivo "pom.xml" do projeto, conforme a versão corrente, e se necessário, mude a configuração do setup da JDK, do intelliJ, para a versão do Java instalada;

- No projeto Maven, o arquivo mais importante do projeto, é o "pom.xml" (e é ele que selecionamos, no momento de importar, o nosso projeto), pois nele está todas as dependências do nosso projeto;

- Para rodar o projeto Maven, no intelliJ: ir na aba "Maven", selecionar "install" - no lifecicle (esta primeira parte, se não me engano, deve ser feita somente na primeira inicialização do projeto), e spring-boot-run - em pluguins;

- Para rodar o projeto Maven, no CMD: Abrir o CMD, navegar até o projeto Maven, entrar na pasta "target", e executar o comando "java -jar exemplo-maven-0.0.1-SNAPSHOT.jar" (o último parâmetro é a compilação do nosso projeto);

- Dica, IntelliJ: Para fechar um projeto, vamos até a aba "File" > "Close Project";

- Para importar o projeto Gradle, no intelliJ, selecionamos a pasta do projeto, e o arquivo "build.gradle";

- O arquivo mais importante, do projeto Gradle, é o "build.gradle";

- Caso haja algum erro com Java, no projeto, mude a versão do Java, no arquivo "build.gradle" do projeto, conforme a versão corrente (por exemplo: sourceCompatibility = '10' // antes era a 11), e se necessário, mude a configuração do setup da JDK, do intelliJ, para a versão do Java instalada;

- Para rodar o projeto Gradle, no intelliJ: ir na aba "Gradle", selecionar "build" - na parte de Tasks > build (esta primeira parte, se não me engano, deve ser feita somente na primeira inicialização do projeto), e bootRun - em Tasks > appication;

- Para rodar o projeto Gradle, no CMD: Abrir o CMD, navegar até o projeto Gradle, entrar na pasta "build", depois entrar na basta "libs", e executar o comando "java -jar exemplo-gradle-0.0.1-SNAPSHOT.jar" (o último parâmetro é a compilação do nosso projeto).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: O que precisamos saber sobre java

- Java: É uma linguagem de programação e plataforma computacional, lançada em 1995, pela Sun Microsystems, por um time, comandado por James Gosling, anos depois, foi adquirido pela Oracle. Diferente de outras linguagens de programação, que são compiladas para código nativo, o Java é compilado para um bytecode, que é interpretado por uma máquina virtual;

- Compilador: Um compilador é um programa que, a partir de um código fonte, cria um programa semanticamente equivalente, porém escrito em outra linguagem, código objeto. Um compilador traduz um programa de uma linguagem textual, para uma linguagem de máquina, específica para um processador, e sistema operacional. O nome compilador é usado principalmente para os programas que traduzem o código fonte de uma linguagem de programação de alto nível, para uma linguagem de programação de baixo nível (por exemplo: Assembly, ou código de máquina);

- Javac: é o compilador do Java;

- Bytecode: É o código originado, da compilação de programas Java. O bytecode, é o programa interpretado, e executado, pela máquina virtual Java (JVM);

- Virtual Machine (VM): Uma máquina virtual (ou, virtual machine), é um software que simula uma máquina física, e consegue executar vários programas, gerenciar processos, mémoria, e arquivos. Tudo isso faz parte de uma plataforma com memória, processador, e outros recursos totalmente virtuais, sem dependência do hardware;

- JVM (Java Virtual Machine): A JVM é uma máquina virtual, que executa programas Java, executando bytecodes, em linguagens de máquina, para cada sistema operacional. Em linguagens compiladas diretamente para um sistema operacional (SO) específico, esse programa não irá executar em outro SO, havendo a necessidade de compilar uma versão do software para cada SO. Com o Java, compilamos para a JVM, o bytecode será executado pela máquina virtual, e não diretemante pelo SO, assim, o software escrito em Java possui portabilidade, para qualquer sistema operacional, porém cada JVM deve ser construída para um SO específico;

- JRE: Java Runtime Environment, ou ambiente de execução do Java, é composto pela Java Virtual Machine (JVM), bibliotecas e APIS da linguagem Java, e outros componentes, para suporte da plataforma Java. Ele representa a parte responsável pela execução do software Java. Comando Linux de instalação do JRE "sudo apt-get install openjdk-8-jre";

- JDK: Java Development Kit (JDK), Kit de Desenvolvimento Java, é um conjunto de utilitários, que permitem criar softwares para a plataforma Java. É composto pelo compilador Java, bibliotecas da linguagem, ferramentas,e a JRE. Comando Linux de instalação da JVM "sudo apt-get install openjdk-8-jdk";

- A JRE, possue opções mais simples, basicamente a baixamos em um ambiente de execução de aplicações Java, já a JDK, em ambientes de desenvolvimento de aplicações Java, por possuir uma gama maior de recursos, além da execução dos programas;

- SE (JSE): Java Standart Edition (SE), é a distribuição mínima da plataforma de desenvolvimento de aplicações Java. Open JDK, é a implementação de referência opensource da plataforma Java, Java SE, que ainda é mantida pela Oracle;

- O JSE (SE), é geralmente destacado, ao falarmos de um desenvolvimento não corporativo, ele é de graça, e opensourcer;

- Java EE: Java Enterprise Edition, é uma extensão da Java SE, que possui suporte a desenvolvimento de sistemas corporativos. Além do mínimo da plataforma, o Java EE possui diversas especificações de partes da infraestrutura de aplicações, como acesso a banco de dados, mensageria, serviços web, parser de arquivos, e outras. Servidores de Aplicações Java EE, sabem seguir essas especificações e implementar os recursos para os usuários. Por exemplo: JBoss (RedHat), WebLogic (Oracle), WebSphere (IBM), e GlassFish (Implementação de referência OpenSource);

- JaKarta EE: Com a falta de investimento da Oracle no Java, ela cedeu todo o código, implementações, e especificações do Java EE, para a Eclipse Foundation, mas como o nome Java EE, é uma marca registrada, foi escolhido JaKarta EE. Agora a evolução das especificações e padrões Java, será feito sob o nome JaKarta EE, com a compatibilidade com o Java EE;

- Exemplo de compilação Java (Linux):
	- entrar no terminal;
	- dar um mkdir hellow-java;
	- dentro da pasta, criar o arquivo "Hellow.java";
	- dentro do arquivo, inserir o código:
		public class Hellow {
			public static void main (String args[]) {
				System.out.println("Hellow World !!!");
			}
		}
	- compilar o código, com o comando: javac Hellow.java ;
	- rodar a classe, com o comando: java Hellow ;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Iniciando um projeto Java

- É possível utilizar, mais de uma versão do Java, Maven, e Gradle. Basta mudar a referência das variáveis de ambiente, para a versão desejada;

- Para ver a estrutura do projeto, no intelliJ: File > Project Struture;

- Para mudar language level do projeto, caso a versão do SDK esteja diferente do language level, no intelliJ: Project Struture > Project > Project language level > e selecionar a versão desejada, do SDK;

- Para deixar compatível o projeto, em uma determinada versão do Java, dentro do arquivo "build.gradle" (o principal arquivo de um projeto, com build Gradle), abaixo das informações de group e version, adicionar a seguinte linha: sourceCompatibility = 1.11;

- O nome, e os argumentos de um método, compõe a sua assinatura;

- Classes sempre devem começar com a primeira letra maísculas, e caso o nome seja composto, o padrão continuara sendo seguido, por exemplo: Usuario, SuperUsuario;

- Modificadores de acesso: definem o acesso/visibilidade de um determinado atributo, ou método, fora do escopo da classe (na qual foram criados);

- Modificadores de acesso, mostrados na aula: public, private, protected;

- Método construtor: é um método, com o mesmo nome da classe, onde passamos informações, de como a classe deve ser instânciada;

- Estrutura básica, de uma classe: construtor (mesmo não declarado, ele existe de forma implicita), atributos, e métodos;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Tipos primitivos, wrappers, não primitivos, e tipagem forte e estática

- Tipos primitivos, do Java, apresentados na aula: 
	byte,
	short,
	int,
	long,
	float,
 	double,
	char,
	boolean;

- Não é possível, atribuir um valor null (nulo), para um tipo primitivo;

- Os tipos primitivos possuem default value (valores padrão), conforme cada tipo, por exemplo, o tipo boolean, que tem o default value false;

- Os tipos primitivos, podem ser declarados, sem ser inicializados, porém se quizermos realizar alguma operação, devemos passar algum valor a eles, pois variáveis primitivas, NÃO ACEITAM NULL (NULO);

- Quantidade, de bits, de cada tipo primitivo, vistos na aula:
	byte - 8 bits (byte b1 = 127 //valor máximo, deste tipo; byte b2 = -128 //valor minímo, deste tipo),

	char - 16 bits (char c1 = 'A' //só é aceito um caracter, neste tipo; char c2 = -100 //não aceita, números muito grandes; //obs.: este tipo aceita alfanuméricos),

	short - 16 bits (short s1 = 32767 //valor máximo, deste tipo; short s2 = -32768 //valor mínimo, deste tipo; //obs.: este tipo, não é alfanumérico),

	int - 32 bits (int i1 = 2147483647 //valor máximo, deste tipo; int i2 = -2147483648 //valor mínimo, deste tipo;),

	long - 64 bits (long l1 = 9223372036854775807L //valor máximo, deste tipo; long l2 = -9223372036854775808L //valor mínimo, deste tipo; //obs.: devemos inserir um "L" (maísculo, ou minúsculo) no final de um número, do tipo long, para indicar ao compilador, que o número é um long),

	float - 32 bits (//valor máximo: 3.402,823,5 E+38; //valor mínimo: 1.4 E-45; float f1 = 65.0f; //obs.:devemos inserir um "f", no final de um número, do tipo float, este tipo é referente aos ponto flutuantes, ou somente flutuantes),

	double - 64 bits (//valor máximo: 1.797,693,134,862,315,7 E+308; //valor mínimo: 4.9 E-324; double d1 = 1024.99;),

	boolean (boolean bo1 = true; boolean bo2 = false; obs.: só aceita os valores: true, e false)

- Palavra reservada, apresentada na aula: void, indica que um método não possui retorno, void NÃO É UM TIPO DE VARIÁVEL;

- Durante a aula, foi criada uma classe, que fazia o get, dos valores primitivos int e boolean (sem os mesmos serem inicializados), ao rodar o programa, chamando os métodos de get, foram retornados os valores 0 e false. Pois os mesmos, são os valores default (padrão), destes tipos primitivos;

- Wrappers: são objetos, que representam os tipos primitivos do Java;

- Wrapper, Autoboxing: Permite que manipulemos a classe dos primitivos, a construção de cada classe primitiva é automática, desta forma conseguimos atribuir um valor null (nulo), ou utilizar diversas funcionalidades disponíveis das classes, dos tipos primitivos. Exemplo: Byte nullByte = null; Boolean bo = Boolean.valueOf("true") //transforma o texto em um valor boolean;

- Wrapper, Unboxing: Permite a atribuição de valores/retornos, de classes primitivas, para um tipo primitivo. Exemplo: int i = new Integer(3) //Esta forma está depreceada, desde a versão nove do Java; int inteiro = Integer.valueOf(1024); //Esta é forma recomendada, de utilizar unboxing; boolean bo = Boolean.TRUE; boolean bo1 = Boolean.getBoolean("false");

- Autoboxing: É quando, você passa o valor puro para um tipo de objeto primitivo (wrapper);

- Unboxing: É quando, constrói o objeto do tipo primitivo (wrapper), e atribui para um tipo primitivo;

- Tipos não primitivos, apresentados na aula:
	String (é uma sequência de caracteres, exemplo de declaração/utilização: String texto "kçlkkçklçk";),
	Number (a classe integer "extend" dela, exemplo de declaração/utilização: Number numero = Integer.valueOf(100); numero.toString()),
	Object (é tipo principal do Java, todos os objetos "extendem" dele, exemplo de declaração: Object o = new Object;),
	Quaisqueres objetos

- Os Wrapper´s, embora estejam separados na explicação de tipos, não são do tipo primitivo;

- Tipagem Estática: significa que o/s tipo/s da variável/eis são verificados em tempo de compilação;

- Tipagem Forte: significa que uma vez, que eu atribui um tipo a uma variável, não será possível mudá-lo (por exemplo: String texto = "aaaa"; texto = 100; //isso não é possível, pois o valor da variável aceita somente sequências de caracteres, não números inteiros); 

- Tipo Inferido: significa que podemos passar valores a uma variável, sem que passemos o seu tipo, por meio da palavra reservada "var", essa funcionalidade foi adicionada ao Java, desde a versão 10, DETALHE, A TIPAGEM CONTÍNUA SENDO FORTE, A DIFERENÇA AQUI, É QUE AO ATRIBUIR UM VALOR A VARIÁVEL, SERÁ SUBENTENDIDO O SEU TIPO (por exemplo: var numero = Integer.valueOf("123456"); var texto = "aaaa";);

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Modificadores de acesso

- Modificadores de acesso: são responsáveis, por habilitar ou não, a visualização de um atributo ou método de uma classe, para outros membros da classe, programas, etc; 

- Modificador de acesso, public: pode ser acessada de qualquer lugar, por qualquer entidade, que possa visualizar a classe a que ela pertence;

- Modificador de acesso, private: os métodos e atributos da classe definidos como privados, não podem ser acessados ou, usados por nenhuma outra classe. Esses atributos e métodos, também não podem ser visualizados pelas classes herdadas;

- Modificador de acesso, protected: torna o membro acessível às classes do mesmo pacote ou, através de herança, seus membros herdados não são acessíveis a outras classes, fora do pacote em que foram declarados;

- Modificador de acesso, default (padrão): a classe e/ou seus membros são acessíveis somente por classes do mesmo pacote, na sua declaração não é definido nenhum tipo de modificador, sendo este identificado pelo compilador;

- Obs. Modificador protect: ATRIBUTOS OU MÉTODOS, COM ESSE MODIFICADOR, SÓ PODEM SER ACESSADOS POR HERANÇA, E SE ESTIVEREM NO MESMO PACOTE;

- Modificador de acesso, abstract: esse modificador, não é aplicado nas variáveis, apenas em classes e métodos, uma classe abstrata não pode ser instanciada, se houver alguma declaração de um método como abstract (abstrato), a classe também deve ser marcada como abstract;

- Classe Abstrata: significa, que ela é UMA IDEIA DE UMA CLASSE, logo ela em si NÃO PODE VIRAR UM OBJETO, por isso ela NÃO PODE SER INSTANCIADA, pois é apenas uma ideia;

- Métodos Abstratos: não possuem corpo, pois são ideias de métodos;

- Ao fazer o extends, de uma classe abstrata, os seus métodos, e atributos, devem ser sobre escritos (Override);

- Embora a classe abstrata, seja uma ideia, e não possa ser instanciada, ela continua sendo um tipo, então podemos usá-la nesta declaração de variável, por exemplo: final FormaGeometrica formaGeometrica = new Quadrado("Quadrado", 10) //Aqui estamos indicando que o objeto a ser criado/instanciado é do tipo forma geométrica, onde sua forma em si (especialização) é um quadrado, ou seja a partir de uma ideia, contruímos algo específico (neste caso, demos um extend na classe abstrata "FormaGeometrica", na classe "Quadrado", onde realmente implementamos as ideias de métodos e atributos, de uma forma, em outras palavras, transformamos a ideia, em realidade);

- Modificador de acesso, static: é usado para a criação de uma variável que poderá ser acessada por todas as instâncias de objetos desta classe como uma variável comum, ou seja, a variável criada será a mesma em todas as instâncias e quando seu conteúdo é modificado numa das instâncias, a modificação ocorre em todas as demais. E nas declarações de métodos ajudam no acesso direto à classe, portanto não é necessário instanciar um objeto, para acessar o método;

- Variável static (estática): declarando uma variável como estática, significa que todas instâncias do objeto, terão os valores alterados, ou seja não serão únicos, como no exemplo da aula, o professor criou uma classe "Cachorro", dentro dela tinhamos um atributo "zoologia", inicializado como "Bipede", ao instanciarmos dois objetos do tipo "Cachorro", e verificarmos o seu valor, vimos que todos ainda estavam como "Bipede", porém ao mudar o valor da zoologia, de um dos cachorros, para "Quadrupede", por exemplo, o valor era refletido, para o outro objeto, mesmo que ele não tivesse mudado o seu valor padrão.

- Método static (estático): permite chamarmos um método, sem que precisemos instanciar um objeto, referenciando uma classe, por exemplo: Cachorro.latir(); //latir é um método estático, dentro da classe Cachorro, ao invés de criarmos/instanciarmos um novo cahorro para executar o latido, simplemente chamamos o método latir, diretamente da classe Cachorro;

- Modificador de acesso, final: quando é aplicado na classe, não permite estender nos métodos, impede que o mesmo seja sobrescrito (overriding) na subclasse, e nos valores de variáveis, não pode ser alterado depois que já tenha sido atribuído um valor;

- Variáveis final: não permitem alteração de seu valor, após a sua primeira atribuição;

- Métodos final: na aula o professor mostrou métodos com argumentos final, logo o argumento recebido, não pode ser alterado, dentro do método;

- Classes final: uma classe final, NÃO PODE SER ESTENDIDA (extends), por outras classes, porém ELA PODE SER INSTANCIADA NORMALMENTE;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Métodos abstratos, default e herança múltipla

- Interfaces:
	Métodos abstratos
		Devem ser implementadors por todos,
		Novos métodos quebram as implementações/contratos
	Métodos default
		São herdados a todos que implementam,
		Novos métodos não quebram as implementações
	Herança múltipla** - no Java, ao contrário de outras linguagens, não permite heranças múltiplas, porém, permite a implementação de diversas interfaces (contratos);

- Na interface, não é obrigatório implementar o seu método default, O MESMO SERÁ HERDADO. Exemplo de default method (método default): 
	default void ligar() {
		System.out.println("Ligando o carro !");
	}; 

- Quando uma classe implementa algo (interface), ela se torna algo, por exemplo: public class Gol implements Carro {} //Gol é um Carro, essa é a leitura correta dessa identificação;

- "Herança múltipla" (ou mais de uma implementação de interface), é capacidade de uma classe ser mais de uma coisa, como no exemplo, da aula, existia uma classe chamada "Fiesta", que implementava as interfaces de "Carro" e "Veículo", lodo entendemos, que o Fiesta, emobora seja um Carro, não deixa de ser um veículo, exemplo dessa implementação: public class Fiesta implements Carro, Veiculo {} //Fiesta é um Carro, e também é um Veículo;

- UM DETALHE IMPORTANTE SOBRE "HERANÇA MÚLTIPLA", NÓS TEMOS QUE IMPLEMENTAR (FAZER O OVERRIDE), DE TODAS AS INTERFACES, ENVOLVIDAS NA HERANÇA (OU NESTE CASO, CONTRATO);

- Ao adicionar novos métodos, ou atributos estáticos (bom, que não sejam default), à uma interface, todas classes que assinaram o contrato com ela, deveram adotar as novas implementações. Porém, se adicionarmos novos métodos default, o contrato não será quebrado, ou seja, as demais classes, não precisam implementar as novas implementações, pois essas já serão herdadas;

- Caso em uma Herança múltipla, uma classe assine implementações paracidas de métodos default, de seus contratos assinados, ele será obrigado a implementá-los. Onde você poder implementar o método da forma que quiser, ou deixar que a superclasse faça isso para você (no caso, deixar que as interfaces, usem as suas próprias implementações default), por exemplo: @Override public void ligar () {Carro.super.ligar(); Veiculo.super.ligar()};

- A técnica de "super", mostrada acima, só pode ser usada pela classe que implementa uma interface;
 
- INTERFACES, PODEM HERDAR, por exemplo: public interface Carro extends Automovel {};

- Enums: 
	Basicamente, é dicionário de dados imutável,
	Não é permitido criar novas instâncias.
	O construtor é sempre declarado como private;
	Por convenção, por serem objetos constantes, e imútaveis (static final), OS NOMES SÃO EM MAIÚSCULOS;

- Exemplo de um enum básico:
	public enum TipoVeiculo {
		TERRESTRE,
		AQUATICO,
		AEREO
	}

- Exemplo de um enum, com métodos e atributos:
	public enum Status {
		OPEN(13, "Aberto");
		CLOSE(02, "Fechado");
		
		private int cod;
		private String texto;
		
		Status(final int cod, final String texto) {
			this.cod = cod;
			this.texto = texto;
		}
		
		public int getCod() {return cod;}
		public String getTexto() {return texto;}
	}

- Acessando um enum, pegando o exemplo básico, como referência:
	TipoVeiculo.TERRESTRE;

- Acessando um enum, pegando o exemplo com métodos e atributos, como referência:
	Status.OPEN;

- Nós conseguimos recuperar todos os valores de um enum, por meio da propriedade ".value()", envolvida em um laço de repetição;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: String e o pacote java.lang

- String: é uma sequência de caracteres;

- A classe String, fica dentro do pacote "java.lang";

- string.charAt(5): o ".charAt(5)", devolve o conteúdo em posição específica de uma String, no caso queremos ver qual o conteúdo na posição 5, da variável string;

- string.length(): o ".length()", irá devolver o tamanho total da String;

- string.trim(): o ".trim()", retirá os espaços em branco, do inicio, e final, de uma String;

- string.toLowerCase(): o ".toLowerCase()", deixa todo o texto, dentro de uma String, minúsculo;

- string.toUpperCase(): o "toUpperCase()", deixa todo o texto, dentro de uma String, maiúsculo;

- string.contains("M"): o ".contains("M")", devolve um boolean, caso tenha o/s caractere/s do parâmetro, o método devolve um TRUE, caso o contrário devolve um FALSE;

- string.replace("n", "$"): o ".replace("n", "$")", permite que troquemos algum/ns caractere/s por outro, no caso estamos querendo trocar todos os caracteres "n", de nossa String, por "$";

- string.equals(" Minha String "): o ".equals(" Minha String ")", devolve um boolean, caso a String informada no parâmetro seja igual a variável string, ele retorna TRUE, caso o contrário devolve um FALSE;

- string.equalsIgnoreCase(" minha string "): o ".equalsIgnoreCase(" minha sTrinG ")", devolve um boolean, caso a String informada no parâmetro seja igual a variável string, ele retorna TRUE, caso o contrário devolve um FALSE, ELE IGNORA SE A STRING ESTÁ MAÍSCULA, OU MINÚSCULA, O IMPORTANTE É VERIFICAR, SE O CONTEÚDO É IGUAL;

- string.substring(1, 2): o ".substring(1, 2)", ele devolve a sequência de caracteres, dentro de um determinado intervalo, no caso ele vai devolver todos caracteres da posição 1 até a 6, dentro da String;

- Ao invés de concatenar as String´s com o "+", podemos usuar "String.format", por exemplo: 
	final var mensagem = String.format("O cliente de %s possuí o sobrenome %s", nome, sobreNome);
	//o "%s", representa os outros parâmetros informados no método, sem ser a própria string de texto, na qual estamos querendo construir;

- Além de formatar String´s, para mostrar textos, conseguimos formatar outros tipos de dado, neste caso o floate, por exemplo:
	String.format("Número %.2f", 1.2375d);
	//aqui estamos indicando querer mostrar um ponto flutuante, com apenas duas casas, depois da vírgula;

- Outra maneira de trabalhar com String´s no Java, é o StringBuilder, exemplo de declaração de variável: var nome = "João"; final var builder = new StringBuilder(nome);

- builder.append("Felix"): o ".append("Felix")", nos permite adicionar mais Strings, a nossa sequência/cadeia de caracteres, neste caso, estamos inserindo "Felix", após o "João";

- builder.reverse(): o ".reverse()", cria uma string, de trás, para frente, por exemplo:
	final var reverse = builder.reverse()
	// reverse = xileFoãoJ;

- builder.insert(0, ;"#").insert(reverse.length(), "#"): o ".insert(0, ;"#")" (o outro insert também), insere caracteres em posições específicas de uma String, no caso estamos inserindo "#", na primeira, e na última posição da String, ficando assim:
	//#xileFoãoJ#;

- Exercício final: estudar e testar demais métodos da classe String que não foram testados, como:
	System.out.printl("A B C D E F G".toCharArray());
	System.out.printl("Aula de Java".split(" "));
	System.out.printl("Aula".concat(" de Java "));
	System.out.printl("1234 asda qw".replaceAll("[0-9]", "#"));

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula:Introdução a condicionais

- if ternário, exemplo
	var condicao = true;
	final var ternario = condicao ? "é verdadeira" : "é falsa";
	//neste exemplo a variável ternario, irá receber "é verdadeira", pois a validação começa do lado esquerdo do "?", ou seja se a condição for true, devolva o que está a direita da "?", caso o contrário, devolva o que está após (ou a direita) de ":"

-  if (!condicao): o "!", nega toda condicao a sua direira;

- operador matemático "%": equivale ao módulo (ou o resto), de uma divisão;

- escrevendo uma multiplicação de forma simplificada:
	var numero = 10;
	numero *= 2;
	// a saída é 20, essa sintaxe é equivalente a esta: numero = numero * 2

- else if: é uma condição intermediária, entre o if e else:

	if (condicao) {
	} else if {
	}else {
	}

- Sort Circuit: usa dos operadores lógicos "&&" e "||", essa técnica, dentro de um if, nos permite validar se uma das condições é verdadeira, e dependendo do resultado esperado executa algo (condição normal de dia a dia, e mais performática);

- Non Sort Circuit: usas os operador "|" e "&", essa técnica, dentro de um if, nos permite validar todas as condições, mesmo com uma das condições atendendo a nossa necessidade, ele faz as validações, e dependendo do resultado esperado, executa algo;

- Incremento:
	++variavel (ou --variavel) - primeiro eu incremento, e depois avalio a expressão
	variavel++ (ou variavel--) - primeiro eu avalio a expressão, e depois incremento;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Laços de repetição

- A diferença entre while, e do while:
	while- testa a condição antes, e executa
	do while - testa a condição depois, e executa;

- Exercício final: exercícios com IntStream:
	IntStream.of(1,2,3,4,5).forEach(n -> {
				 	System.out.println(n);});
	IntStream.range(0,3).forEach(n -> {
					System.out.println("Número = " + n)});

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Convenções de nomes

- As convenções devem ser seguidas em:
	Nome de Classes
	Nome de Métodos
	Nome de Variáveis;

- Convenção de nome de classes (Kamel Case):
	Normal (ou sem nomes compostos) - Primeira letra maiúscula - exemplo: String
	Com nomes compostos - Segunda, e demais nomes com letra maiúscula - exemplo: BuilderDeString;

- Convençao de nome de métodos:
	Normal - o nome é todo minúsculo - exemplo: verifica
	Com nomes compostos - o primeiro nome é minúsculo, e os demais nomes, começam com a primeira letra maiúscula - exemplo: verificaAlunoAprovado;

- Convenção de nome de variáveis:
	Normal - o nome é todo em minúsculo - exemplo: nome;

- Plugins, para garantir que as convenções Java, sejam seguidas, durante o desenvolvimento:
	Checkstyle Gradle Plugin - estilo de escrita
	PMD Gradle Plugin - boas práticas

- Para instalar os plugins, no intelliJ:
	ir até o arquivo "build.gradle"
	na parte de plugins, adicionar a linha id: 'checkstyle'
	na parte de plugins, adicionar a linha id: 'pmd'

- Para configurar os plugins, no intelliJ:
	criar uma pasta chamada config, no projeto
	criar uma pasta dentro de config chamada de "checkstyle"
	dentro da pasta checkstyle, inserir um arquivo ".xml", de configurção, disponível no site do plugin, olhar na parte de documentação
	criar uma pasta dentro de config chamada de "pmd"
	dentro da pasta pmd, inserir um arquivo ".xml", de configurção, disponível no site do plugin, olhar na parte de documentação
	dentro do arquivo build.gradle, adicionar o seguinte código, abaixo de "dependencies":
		checkstyle {
			toolVersion = '8.21' // versão da ferramenta, que você deseja utilizar
			showViolations = true
			configureFile = file ("config/checkstyle/checkstyle.xml")
		}

		pmd {
			//ruleSets = ["category/java/errorprone.xml", "category/java/bestpractices.xml"]
			ruleSetFiles = files("config/pmd/ruleset.xml")
			toolVersion = '6.15.0'
			ignoreFailures = true
			consoleOutput = true	
		}

- Para ativar as configurções dos plugins:
	No menu gradle > Tasks > build
	executar a task "build"
	Obs.: essa ação deve ser executada todas as vezes, que quisermos encontrar alguma falha, em relação a boas práticas, pois na saída da execução do build, existe abas com os nossos plugins, que informão justamente essas inconssistências

- Se você quiser, por um acaso, não mostrar determinada informação do plugin checkstyle, no console, pós build, basta retirar a tag "module", referente a informação não interessante;

- Se você quiser, por um acaso, não mostrar determinada informação do plugin pmd, no console, pós build, basta retirar a tag "rule", ou adicionar a tag "exclude", com as informações referente a informação não interessante;

- Para não gerar erros, em novos builds, executar a task "clean"; 

- Ao buildar os plugins, arquivos html, serão criados, nas pastas onde estiver localizado o xml de configurção, onde os mesmos indicam os erros no projeto, em forma de relatório;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Debug de código

- Debug: é uma ferramenta extremamente importantes e poderosa, pois possibilita análisar o código, evitando bugs, logo ganhando em qualidade;

- BreakPoints: são pontos de parada, você seleciona um determinado ponto, onde sistema deve parar, no momento da depuração;

- Para definir um breakpoint, no intelliJ: na parte esquerda do código, onde fica marcado as linhas de cada instrução, basta clicar duas vezes em um número de linha, se aparecer uma bolinha vermelha, é porque o breakpoint foi criado;

- Diferença entre Run e Debug: Run executa o código, o debug executa o código para análise de erro, podendo analisar o passo a passo do algoritmo, até o/s ponto/s de parada definido/s;

- Para executar o debug, você tem 3 opções, executar pelo próprio código (pelo ícone do lado esquerdo do método principal), no menu superior ao código, e no menu inferior (terminal, uma das opções é do debug);

- Para ver as opções de debug, basta prestar atenção no console "debug" abaixo do nosso código, por lá temos diversas opções para proceder a nossa análise no código, conforme a necessidade;	

- A opção "resume" do debug, avança a execução sempre até o próximo breakpoint;

- A opção "step over", do debug, avança até a próxima linha do código;

- A opção "step into", do debug, entra dentro de um método, conforme você entra dentro de métodos, o debug vai empilhando eles em threads, para sair e voltar a thread (ou método, ou classe) anterior, basta clicar na opção "step out";

- Na aba de variáveis, do debug, é possível mudar o nome delas, clicando com o botão direito em cima de uma, e selecionando a opção "set";

- Para avaliar uma linha no debug, selecione a mesma, e no debug, selecione a opção "Evaluate Expression", na aula, o professor usuou para avaliar a linha, onde o cálculo de IMC, era feito;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Paradigma em orientação a objetos

- Frase de Robert "Uncle Bob" Martin (livro Arquitetura Limpa): "A programação Orientada a Objetos impõe disciplina sobre a transferência indireta do controle";

- Argumentação de Robert "Uncle Bob" Martin (livro Arquitetura Limpa): "... a pilha de chamadas funções ... poderia ser movida para HEAP (área de memória não necessariamente ordenada - diferente da stack) possibilitando que as variáveis locais declaras por uma função existissem muito depois que a função retornasse...";

- Argumentação de Maurício Aniche (livro Orientação a Objetos e SOLID para Ninjas): "A diferença entre um código procedural, e um O.O é bem simples. EM CÓDIGOS PROCEDURAIS (...) escolher o melhor ALGORITMO É O MAIS IMPORTANTE (...) Já em linguagens ORIENTADO A OBJETOS (...) pensar no PROJETO DE CLASSES (...) como se encaixam (...) e como serão estendidas (ou, entendidas) É O QUE MAIS IMPORTA";

- Classe: Vamos entender uma classe como um modelo a ser seguido. Uma classe vai funcionar como uma espécie de molde que nos servirá como base para contruir algo. Por exemplo, quando pensamos em construir uma casa, nós fazemos uma planta baixa. Ela será o modelo, que utilizaremos para construir algo concreto;

- Exemplo, básico de uma classe:
	public class Pessoa { //classe pessoa = modelo de pessoa
		private String nome = "Marcos"; //atributo pessoa = característica da pessoa

		public String getNome() { //método pessoa = ações de uma pessoa (por exemplo, se perguntarmos o nome de uma pessoa, executamos este método)
			return nome;
		}
	}

- Objeto: Agora que entedemos que temos um modelo, que podemos seguir. O que podemos fazer com esse modelo ? Bom.. Nós fizemos a analogia da casa, certo ? Depois de termos a planta baixa, nós começamos a construir. E o resultado do que nós construímos, vamos chamar de objeto. Quando nós utilizamos a nossa classe Pessoa - mostrada no código anterior - para criar um objeto, nós diremos que estamos INSTACIANDO UM OBJETO DA CLASSE PESSOA. Esse termo é bem simples de entender, o que acontece é que podemos criar VÁRIOS OBJETOS de uma mesma classe, ou seja, várias INSTÂNCIAS DE OBJETOS.

- Exemplo, básico de um objeto:
	puclic class ExemploPessoa {
		public static void main (String[] args) {
			Pessoa pessoa = new Pessoa ();
			System.out.println(pessoa.getNome());
			//Saída: Marcos
		}
	}

- Atributos: Agora vamos pensar no que nós definimos como NOME. Foi tão intuitivo, nós pensarmos que uma pessoa teria um nome, que nem demos a importância a ele, o nome é uma característica de uma Pessoa e pode ser diferente de pessoa para pessoa. O nome é um ATRIBUTO, da pessoa;

- Métodos: Agora vamos pensar no que uma pessoa pode fazer. Por exemplo, uma pessoa pode falar, pensando em um cenário específico, uma pessoa pode falar o seu nome, as ações que nós definimos numa classe, nós chamamos de MÉTODOS.

- Exercício final: Crie uma classe Carro. Nessa classe classe, você deverá ter a quantidade de pessoas ques estão dentro do carro. E também é preciso, que tenha uma forma de adicionar, e remover pessoas de dentro do carro;

- A PROGRAMAÇÃO ORIENTADA A OBJETOS É COMPOSTA POR 4 PILARES;

- OS PILARES DA PROGRAMAÇÃO ORIENTADA A OBJETOS SÃO:
	ABSTRAÇÃO
	ENCAPSULAMENTO
	HERANÇA
	POLIMORFISMO

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Criando objetos com construtores

- Construtores: Podemos entender o termo CONSTRUTOR no sentido literal, afinal vamos CONSTRUIR UM OBJETO, por meio de um construtor, CRIAMOS UM OBJETO, baseado em uma classe e assim o ALOCAMOS EM MEMÓRIA, ao criarmos um objeto, dizemos que estamos instanciando um objeto;

- Exemplo, básico, de construtor:
	public class Pessoa {
		private var nome = "Marcos";
		
		public Pessoa() { //construtor vázio

		}

		public String getNome () {
			return nome;
		}

		public void setNome (String nome) {
			this.nome = nome;
		}
	}  

- Exemplo de criação de instância, com base na classe acima:
	Pessoa pessoa = new Pessoa();

- Se nós não implementarmos um contrutor (explicitar), o Java criará um construtor, vázio, de forma implicita, automaticamente;

- No momento de instanciar uma classe, onde os contrutores estão implícitos ou explicitos, porém vázios (padrão), a forma de instanciar não muda, por exemplo
	Pessoa pessoa = new Pessoa ();

- Nós podemos criar construtores parametrizados, dessa forma, conseguimos definir um contrato onde sempre será obrigatório passar alguma informação na hora de instanciar a classe;

- Se tivermos, um construtor com parâmetros, e precisarmos, por um acaso instanciar um objeto da classe com uma construção vázia, então devemos explicitar um construtor vázio, em nossa classe;

- Exemplo, contrutor com parâmetro:
	public class Pessoa {
		private var nome = "Marcos";
		
		public Pessoa() { //construtor vázio

		}

		public Pessoa (String nome) {
			this.nome = nome;
		}

		public String getNome () {
			return nome;
		}

		public void setNome (String nome) {
			this.nome = nome;
		}
	}

- E existe um destrutor ? Em Java não existe o conceito de destrutor explícito, lembra que falamos que quando instanciamos, estamos na verdade, alocando o objeto em memória ? Pois bem... Desalocar esse objeto, fica por conta do GC (Garbarage Colector - Coletor de lixo do Java);

- Exercício final: Crie uma classe Carro com os atributos: Marca - String, Modelo - String, Ano - Integer, Variante - String. Essa classe deve garantir que Modelo, Marca e Ano, sempre sejam passados na hora de instanciar um objeto;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Encapsulamento, herança e polimorfismo

- Encapsulamento: Quando falamos de ENCAPSULAMENTO, estamos falando efetivamente em proteger alguma informação de alguma forma, ou seja, com uma CÁPSULA;

- O que queremos, com o encapsulamento de informações ? Queremos GARANTIR A NOSSA IMPLEMENTAÇÃO e que O ACESSO A DETERMINADOS DADOS ESTEJAM REALMENTE PROTEGIDOS do acesso externo;

- Exemplo de encapsulamento:

	public class Pessoa {
		private String nome;
		private LocalDate dataNascimento;

		public Pessoa (String nome, int dia, int mes, int ano) {
			this. nome = nome;
			this.dataDeNascimento = LocalDate.of(ano, mes, dia);
		}

		public int calculaIdade() {
			return Period.between(dataDeNascimento, LocalDate.now()).getYears();
		}

		public String getNome() {
			return nome;
		}

		public LocalDate getDataNascimento() {
			return dataNascimento;
		}

		public void setNome(String nome) {
			this.nome = nome;
		}
	}

- Herança: Como o próprio nome já diz, essa é a capacidade de uma Classe herdar o comportamento de outra;

- Exemplo de Herança: 

	public class Veiculo {
		private String modelo;
		private String marca;
		
		public void acelerar () {
			System.out.println("Acelerando ...");	
		}
	}

	public class Carro extends Veiculo { //Carro é um veículo
		private int quantidadeDePortas;
	}

	public class Motocicleta extends Veiculo { //Motocicleta é um veículo
		private String cilindradas;
	}

- Herança X Composição: Existe um vasto e antigo debate, em relação a utilização de herença. Algumas bibliografias, inclusive defendem que ela nunca deva ser utilizada. E o grande problema tem relação com o tópico anterior: O ENCAPSULAMENTO. A subclasse necessita conhecer, em muitos casos, a implementação da superclasse, o que cria um acoplhamento e quebra a nossa premissa básica do isolamento, que vimos no encapsulamento. Por conta disso, algumas pessoas optam pelo uso de composição, ao invés da herença;

- Polimorfismo: Quando falamos em herança, o verbo SER é mandatório na nossa forma de falar, sobre a classe. Entendemos, portanto, que um carro É UM VEÍCULO e uma MOTOCICLETA tabém É UM VEÍCULO. Quando falamos de Polimorfismo, estamos querendo entrar em um cenário onde um objeto, pode ser referenciado de várias maneiras;

- E onde entra o Polimorfismo ? Ele nos garantirá a capacidade de um objeto ser referenciado, de múltiplas formas. O Java será capaz de identificar qual objeto foi instanciado e, assim, escolher qual método será utilizado;

- Exemplo de Polimorfismo:
	
	public class Veiculo {
		private String modelo;
		private String marca;
		private double valorVenal;
		
		public void acelerar() {
			System.out.println("Acelerando ...");	
		}

		public double calcularImposto() {
			return this.valorVenal * 0.01;
		}

		public getValorVenal() {
			return valorVenal;
		}
	}

	public class Carro extends Veiculo { //Carro é um veículo
		private int quantidadeDePortas;

		public double calcularImposto() { //polimorfismo
			return this.getValorVenal() * 0.07;
		}
	}

	public class Motocicleta extends Veiculo { //Motocicleta é um veículo
		private String cilindradas;
		
		public double calcularImposto() { //polimorfismo
			return this.getValorVenal() * 0.03;
		}
	}

- Exercício final: Vamos pensar em um cenário onde temos Funcionários. Esses funcionários podem ser: Gerente, Supervisor e Atendente. Cada tipo de funcionário desses, tem políticas diferentes de impostos: Gerente - paga 0,1% do salário, Supervisor - paga 0,05% do salário, Atendente - paga 0,01% do salário. Monte um modelo que atenda esse cenário;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Aprenda as características específicas em orientação a objetos (no Java)

- this: Quando estamos trabalhando com o termo this, no Java, estamos, na verdade, fazendo uma AUTO REFERÊNCIA;

- Esse conceito (this) faz mais sentido quando estamos falando de construtores e métodos, exemplo:
	public class Veiculo {
		private String modelo;

		public String getModelo() {
			return modelo;
		}

		public void setModelo(String modelo) {
			this.modelo = modelo;
		}
	}

- super: Analogamente ao THIS, quando falamos no SUPER também estamos fazendo uma referência, mas dessa vez estamos fazendo REFERÊNCIA A SUPERCLASSE em um cenário de herança;

- ATENÇÃO: COMO EM JAVA, TODAS AS NOSSAS CLASSES HERDAM DE OBJECT, SE USAMOS O SUPER EM UMA CLASSE QUE NÃO TEM UM EXTENDS EXPLÍCITO, ESTAMOS FAZENDO REFERÊNCIA AO OBJECT;

- Exemplo da utilização de super (com construtores):
	public abstract class Veiculo {
		private String modelo;
		private String marca;
		private double valorVenal;
		
		public Veiculo(String modelo, String marca, double valorVenal) {
			this.modelo = modelo;
			this.marca = marca;
			this.valorVenal = valorVenal;
		}
	}

	public class Carro extends Veiculo { //Carro é um veículo
		private int quantidadeDePortas;
		
		public Carro(String modelo, String marca, double valorVenal) {
			super(modelo, marca, valorVenal); //estou usando o construtor, da classe pai
		}

		public Carro(String modelo, String marca, double valorVenal, int quantidadePortas) {
			super(modelo, marca, valorVenal);
			this.quantidadePortas = quantidadePortas;
		}
	}

- equals: Como sabemos, todas as classes em Java, herdam de Object. E, portanto, tem por padrão, alguns métodos. Um deles é o EQUAL, que serve para fazer comparações entre objetos. Entretanto, este método possui algumas peculiaridades. Por padrão, quando estamos comparando dois objetos, estamos comparando a referência deles. Então se instanciarmos dois carros, por mais que eles tenham exatamente as mesmas informações, o Java não é capaz de identificar. Mas poderíamos sobreescrever o método equals() para que nossa lógica funcione do jeito que gostaríamos. TENHA EM MENTE QUE É UMA BOA PRÁTICA SOBREESCREVER ESTE MÉTODO;

- Exemplo sem sobreescrever o método equals:
	Veiculo carro1 = new Carro("Uno", "Fiat", 200000);
	Veiculo carro2 = new Carro("Uno", "Fiat", 200000);

	System.out.println(carro1.equals(carro2)); //false, pois são instâncias diferentes, por mais que tenham os mesmos dados

- Exemplo sobreescrevendo o método equals (dentro da classe Veículo):
	@Override
	public boolean equals(Object obj) {
		if (obj == null)
			return false;
		
		Veiculo comparavel;

		if (obj instaceof Veiculo)
			comparavel = (Veiculo) obj;
		else
			return false;

		if (comparavel.marca == this.marca && comparavel.modelo == this.modelo && comparavel.valorVenal == this.valorVenal)
			return true;
		
		return false
	}

- HashCode: Quando falamos em hashCode, precisamos pensar em um código gerado que garanta um caráter único ao nosso objeto. Essa pode ser uma forma muito interessante para que possamos comparar se realmente um objeto é igual ao outro. Temos que garantir que a implementação da lógica de hashCode sempre respeite as mesmas regras, pois quando compararmos os nossos objetos, o nosso fator de comparação será ele;

- Exemplo de hashCode, sobreescrito:

	@Override
	public int hashCode (){
		return Objects.hash(modelo, marca, valorVenal);
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null)
			return false;
		
		Veiculo comparavel;

		if (obj instaceof Veiculo)
			comparavel = (Veiculo) obj;
		else
			return false;

		if (this.hashCode() == obj.hashCode())
			return true;
		
		return false
	}
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Introdução a aula (Aprenda sobre S.O.L.I.D. com Java)

- O que é SOLID: SOLID é um acrônimo dos princípios da programação orientada a objetos, descritos por Robert C. Martin ("Uncle Bob"). Auxiliam o programador a escrever CÓDIGOS mais LIMPOS, FACILITANDO a REFATORAÇÃO e estimulando o REAPROVEITAMENTO DO CÓDIGO;

- Significado do acrônimo SOLID:
	S.r.p - Single Responsability Principle (Princípio da responsabilidade Única),
	O.c.p - Open Closed Principle (Princípio aberto fechado),
	L.s.p - Liskov Substituition Principle (Princípo da subustituição de Liskov),
	I.s.p - Interface Segregation Principle (Princípio de segregação da interface),
	D.i.p - Dependency Inversion Principle (Princípio da inversão da dependência)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Single Responsability Principle

- Frase de Robert C. Martin: "A class should have one, and only one, reason to change" - Uma classe deve ter um, e somente um, motivo para mudar. >> Isso quer dizer que a classe deve possuir UMA ÚNICA RESPONSABILIDADE dentro do software;

- God Class (Classe Deus) - Ela possuí um código longo, que assume diversas responsabilidades controlando assim tudo (como Deus - God);

- Para evitar God Class, nós dividimos as classes, de acordo com a sua REAL RESPONSABILIDADE, como no exemplo apresentado pelo professor, onde ele dividiu as tarefas de uma ordem de compra em N classes, como: OrdemDeCompra, OrdemDeCompraRepository (realiza o CRUD da aplicação), OrdemDeCompraEmail (possibilita o envio da ordem de compra por email), etc. Desta forma, fica mais fácil a manutenção, e também de manter essas classes, ao invés de possuir uma classe só chamada "OrdemDeCompra", com todas as tarefas;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Open Closed Principle

- Frase de Robert C. Martin: "You should be to extend a classes behavior, without modifying it." - Você deve poder estender um comportamento de classe, sem modificá-lo >> Isso significa que os objetos devem estar ABERTOS PARA EXTENSÃO, mas FECHADOS PARA MODIFICAÇÃO. Quando novos comportamentos precisam ser adicionados no software, DEVEMOS ESTENDER E NÃO ALTERAR O CÓDIGO FONTE ORIGINAL;

- O princípio Open Closed Principle, é utilizado no padrão de projeto strategy;

- No Open Closed Principle, usamos uma interface para guardar os nossos métodos, e quem precisar de determinada operação herda/assina a interface/contrato para implementá-lo a sua maneira. Na aula o professor mostrou a facilidade de se adotar este princípio, pegando o exemplo dele, dos descontos de livro para cada estilo literário, neste cenário cada livro possuia uma classe com um método que representava o cálculo de seu desconto, e havia uma classe de controle que agrupava cada método de desconto conforme a classe (de estilo literário), com a ambientação feita, imagine adicionarmos mais uma classe com o desconto do livro, o que isso causaria ? bom, isso deixaria a classe de controle com mais um método, implementando um desconto para um estilo de livro diferente, isso em larga escala, ficaria muito complexo de adminitrar, então como solução, o que fazer ? na aula o professor, implementou uma interface com um método de desconto, e depois fez com que as classes de cada estilo literário assinasse (herdasse/implementasse) o contrato da interface, onde cada uma das classes assinou, de acordo com a sua necessidade, e finalmente na classe de controle, havia somente um método de desconto que recebia como parêmetro UM objeto do tipo da INTERFACE, isso resumiu muito o tamanho e a complexidade do código;

- Resumindo o entendimento sobre o princípio Open Closed Principle, usamos uma interface para agrupar métodos em comum, à N classes, fazendo com que as classes interessadas nos métodos desta interface, assinem um contrato, para implementar o método, de acordo com a sua necessidade. No exemplo as classes de estilos literários, assinavam a interface para implementar o método de desconto, onde cada uma das classes, possuia um desconto diferente.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Liskov Substituition Principle

- Frase de Robert C. Martin: "Derived classes must be substitutable for their base classes." - Classes derivadas devem ser substituídas por suas classes base;

- O princípio da substituição de Liskov foi introduzido por Barbara Liskov em 1987: "Se para cada objeto O1 do TIPO S há um objeto O2 do TIPO T de forma que, para todos PROGRAMAS P, o comportamento de P é inalterado quando O1 é substituido por O2, então S É UM SUBTIPO DE T";

- Na aula o professor deu o exemplo de duas figuras geométricas: retangulo e quadrado. Onde, o retangulo herdava do quadrado, alterando os atributos do pai (com super), de acordo com as suas caractrísticas, e na hora de instanciar um retangulo, ficou algo mais ou menos assim: Retangulo retangulo = new Quadrado. Bom, ao mudar alguns atribitos do objeto, e realizar cálculo, o resultado foi inesperado (incorreto), e isso aconteceu porque as informações de pai e filho se substituiram, causando este resultado. Como solução, o professor sugeriu usar os príncipios apresentados anteriormente;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Interface Segregation Principle

- Frase de Robert C. Martin: "Make fine grained interfaces that are client specific." - Faça interfaces refinadas que são específicas do cliente;

- Uma classe NÃO DEVE ser forçada a IMPLEMENTAR interfaces e MÉTODOS que NÃO SERÃO UTILIZADOS;

- É melhor criar INTERFACES mais ESPECÍFICAS ao ÍNVES DE termos uma única INTERFACE GENÉRICA;

- Na aula o professor deu o seguinte exemplo: havia uma interface de ave (com os métodos de: bicar, chocarOvos, e voar), e essa interface era implementada pelas classes pato e pinguim, só que tinha um pequeno problema, pinguim, o pinguim tinha o método de voar, mais não iria utilizar (pois ele não voa), e isso estava ferindo o princípio de Interface Segregation Principle. Então para resolver este problema, o professor segregou a interface, ou seja, deixou uma interface "Ave" com métodos comuns a todas as aves, e criou outra (herdando de "Aves") chamada "AvesVoam" onde ela possuia o método de voar , e os demais comuns as aves. Resolvendo assim, agora o pato pode voar (implementando a interface "AvesVoam"), e o pinguin não (implementando a interface "Ave");

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Dependency Inversion Principle

- Frase de Robert C. Martin: "Depend on abstractions, not on concretions." - Dependa de abstrações e não implementções;

- Um módulo de alto nível não deve depender de módulos de baixo nível, ambos devem depender da abstração;

- Obs.: Inversão de dependência NÃO É igual a injeção de dependência;
  
- Na aula o professor apresentou um exemplo, em relação a uma classe de conexão de banco de dados (no caso, MySqlConnection), e uma outra de CRUD (repository). A classe de CRUD possuía os métodos com as transações, e no seu construtor ela mantinha a conexão com o banco de dados, no construtor criavamos uma nova instância da classe de conexão com o de banco de dados e atribuiamos o valor a uma várivel interna/global (na qual iriamos manipular nos demais métodos). Bom, até aqui tudo bem, o problema é quando resolvermos trocar a base de dados, pois teríamos de modificar toda a implementação da classe CRUD. Para resolver isso, foi criada uma interface (DbConnection) contento as conexões de banco de dados, a classe de conexão implementava esta interface, e a classe CRUD modificou o tipo da variável local de acordo com a conexão (interface DbConnection) e passou receber a interface (DbConnection) por parêmetro e atribuir a variável local, no seu construtor, resolvendo o problema;

- Resumindo o entendimento de Dependency Inversion Principle, nós a utilizamos para passar a responsabilidade do tratamento de um objeto, para a classe que queira utilizar a nossa classe;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Classe Date

- java.util.Date: A implementação do java.util.Date está na JDK desde sua versão 1.0, ou seja, é de se esperar que algumas coisas não se mostrem tão interessantes nos dias atuais, dado a sua idade;

- construtores Java Date:
	Date(),
	Date(int year, int month, int date),
	Date(int year, int month, int date, int hrs, int min),
	Date(int year, int month, int date, int hrs, int min, int sec),
	Date(long date),
	Date(String s)

- construtores DEPRECATED (Depreciado), desde a versão 1.1 da JDK:
	Date(int year, int month, int date),
	Date(int year, int month, int date, int hrs, int min),
	Date(int year, int month, int date, int hrs, int min, int sec),
	Date(String s)

- os contrutores adotados para aula (e recomendados pelo Java), são:
	Date(),
	Date(long Date)

- Date(): Este construtor vai alocar um objeto da classe Date e o INICIALIZARÁ COM O MILISSEGUNDO MAIS PRÓXIMO do período da sua execução;

- exemplo de como instânciar um objeto date, com o construtor vázio:
	Date novaData = new Date();
	System.out.println(novaData); //retorna o objeto com todos os atributos (de Date) da data atual, por exemplo: Tue 16 00:51:20 BRT 2019

- Date(long date): Diferente do construtor anterior, esse construtor espera que você passe os milessegundos com base no padrão de tempo (epoch) que usa como referência 1 DE JANEIRO DE 1970 00:00:00;

- Epoch: "O epoch timestamp é um padrão largamente aceito para representar uma data como um inteiro 32-bits a partir do início do UNIX EPOCH...";

- System.currentTimeMillis(): Este método estático vai nos retornar o milissegundo mais próximo de sua execução com base no sistema operacional;

- exemplo de como instânciar um objeto date, com o construtor com long;
	Long currentTimeMillis = System.currentTimeMillis();
	
	Date novaData = new Date(currentTimeMillis);

	System.out.println(novaData);

- Métodos úteis, Java Date, para manipulação de datas:
	método			retorno		descrição
	after(Date);		boolean		Checa se o objeto data de referência é posterior ao comparado
	before(Date)		boolean		Checa se o objeto data de referência é anterior ao comparado
	compareTo(Date)		int		Compara dois objetos data
	equals(Date)		boolean		Checa se os objetos são iguais
	getTime()		long		Retorna a data em milissegundos
	setTime(long)		void		Define uma data com base em milissegundos
	from(Instante)		static Date	Define uma data com base em um Instant
	toInstant()		Instante	Retorna um Instant com base em um date

- exemplo, métodos, after(Date) e before(Date):
	Date dataPassado = new Date(milissegundos de 2017);
	Date dataFuturo = new Date(milissegundos de 2022);
	
	boolean isAfter = dataPassado.after(dataFuturo);
	//false

	boolean isBefore = dataPassado.before(dataFuturo);
	//true

- exemplo, métodos, compareTo(Date) e equals(Date):
	Date dataPassado = new Date(milissegundos de 2017);
	Date dataFuturo = new Date(milissegundos de 2022);
	Date dataFuturo = new Date(milissegundos de 2022);

	boolean isEquals = dataFuturo.equals(dataFuturo);
	//false

	int compareCase1 = dataPassado.compareTo(dataFuturo); //-1 - anterior a data comparada - ou seja está no passado, na linha temporal
	int compareCase2 = dataFuturo.compareTo(dataPassado); //1 - esta a frente da data de referância - ou seja no futuro, na linha temporal
	int compareCase3 = dataFuturo.compareTo(dataFuturo);  //0 - as datas são iguais

- Classe Instant
	Surgiu na JDK 1.8,
	Imutável e Thread safe,
	Modela um ponto instentâneo de uma linha do tempo,
	Indicado para gravar marcações temporais em eventos da sua aplicação

- exemplo, de utilização da classe Instant:

	Date dataInicio = new Date(currentTimeMillis); //Tue Dec 12 22:26:47 BRST 2017

	Instant instant = dataInicio.toInstant(); //2017-12-13T00:26:47.6912

- Exercício final: Aplique o que aprendemos
	Descubra o timeInMillis do dia que você nasceu,
	Converta em um objeto Date,
	Verifique se ele é ANTERIOR ou POSTERIOR a 15 DE MAIO DE 2010

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Classe Calendar  

- java.util.Calendar: Já na JDK 1.1 foi observado a necessidade de facilitar alguns recursos que a classe Date oferecia. Sendo assim, a classe Calendar foi criada. Com isso, uma série sw métodos e construtores da classe Date foi depreciada. Por exemplo, o construtor Data(int year, int month, int date);

- Calendar: É uma classe abstrata, que provê métodos para converter data entre um instante específico. O Calendar possui alguns campos específicos para manipulação como MONTH, YEAR, HOUR, etc;

- Capturando o instante atual com o Calendar:
	Calendar agora = Calendar.getInstance();
	//devolde um objeto com uma série de informações, conforme o calendário gregoriano

- exemplo, de utilização do calendar:
	Calendar agora = Calendar.getInstance();

	agora.getTime(); //devolve a data, no formato do Date
	agora.add(Calendar.DATE, -15); //tira 15 dias, da data atual
	agora.add(Calendar.MONTH, 4); //adiciona 4 meses a data atual
	agora.add(Calendar.YEAR, 2); //adiciona dois anos a data atual

- imprimindo datas e horas:
	Calendar agora = Calendar.getInstance();

	System.out.println("%tc\n", agora); // Dom jul 14 20:58:11 BRT 2019
	System.out.println("%tF\n", agora); // 2019-07-14
	System.out.println("%tD\n", agora); // 07/14/19
	System.out.println("%tr\n", agora); // 08:58:21 PM
	System.out.println("%tT\n", agora); // 20:58:11

- Exercício final: Um cliente tem 10 dias para pagar uma fatura após sua data de vencimento sem que os juros sejam cobrados. Caso essa data caia em um sábado ou domingo, o cliente pode pagar na segunda-feira seguinte. Crie uma estrutura que receba uma data de vencimento e calcule quantos dias ele tem de pagar;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Classe DateFormat

- java.text.DateFormat: Nesse ponto em que estamos existem basicamente, duas classes para formatação de datas. O DATE FORMAT,  e o SIMPLE DATE FORMAT. Ambas oferecem maneiras de formatar e parsear a saída das datas;

- exemplo de utilização do DateFormat:
	Date agora new Date();
	
	String dateToStr = DateFormat.getInstance().format(agora); // 14/07/19 22:51

	dateToStr = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT).format(agora); // 14 de Julho de 2019 22:51

- SimpleDateFormat: traz uma grande facilidade que é definir um padrão de formatação para a saída de data que você deseja; 

-  exemplo de utilização do SimpleDateFormat:
	Date agora = new Date();
	
	SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");

	String dataFormatada = formatter.format(agora); // 14/07/2019

- Exercício Final: Converta a Data atual no formato DD/MM/YYYY HH:MM:SS:MMM (prestar atenção, pois alguns dos parâmetros não possuem letras maiúsculas)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Datas no Java8

- O Java 8 veio com uma série de novidades para facilitar o trabalho com Datas. E a grande melhoria está no pacote java.time que foi herdado do projeto Joda Time;

- Trabalhar com datas nunca foi tão fácil com esse novo pacote. Nele destacam-se três classes:
	LocalDate,
	LocalTime,
	LocalDateTime

- Basicamente, o que tínhamos até então eram as classes que vimos até agora: Date e Calendar. Com o uso constante, elas se mostram confusas e trabalhosas. Além de serem mutáveis;

- LocalDate: É uma classe imutável para representar uma data. Seu formato padrão é yyyy-MM-dd;

- exemplo de utilização LocalDate:
	LocalDate hoje = LocalDate.now(); //2019-07-14

	LocalDate ontem = hoje.minusDays(1); //2019-07-13

- LocalTime é uma classe imutável que representa um padrão de hora-minuto-segundo. LocalTime pode ser representado até o nível de nonosegundos. Exemplo: 12:22:10:123212345. Sua utilização é simular ao LocalDate;

- exemplo de utilização de LocalTime: 
	LocalTime agora = LocalTime.now(); //23:53:58.421

	LocalTime maisUmaHora = agora.plusHours(1); //00:55:37.421

- LocalDateTime: Funciona como uma espécie de junção entre o LocalTime e o LocalDate. Também é uma classe imutável e você consegue trabalhar com dia e  hora de uma sóvez. Você pode manipular a data e hora com precisão de nonosegundos. Exemplo: 2nd October 2007 at 13:45.30.123456789;

- exemplo de utilização do LocalDateTime

	LocalDateTime agora = LocalDateTime(); //2019-07-15T00:02:16.076
	
	LocalDateTime futuro = agora.plusHours(1).plusDays(2).plusSeconds(12); //2019-07-17T01:02:28.076

- Exercício Final: Adicione 4 anos, 6 meses e 13 horas, ao momento 15/05/2010 10:00:00;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Aprenda os conceitos e como trabalhar com Arrays

- Array: Array ou Matriz, é uma estrutura de dados que nos permite organizar valores na memória. Fazem parte da bibliotece java.util que á nativa do Java. Armazenam elementos do mesmo tipo. Podem ser unidimensionais ou multidimensionais;

- A diferença entre um array e uma lista: dentro de um array só será permitido guardar dados com o mesmo tipo de dado do Array, já em uma lista, não necessariamente;

- Detalhes de um Array:
	Cada item em um array é chamado de elemento,
	Cada elemento é acessado pela posição numérica (índice),
	O índice inicia a partir de 0,
	Ao se declarar um array, todos os índices são inicializados em 0,
	Arrays não podem mudar de tamanho, a partir do momento que uma array foi criada, ela não pode mudar de tamanho,
	Se você precisar de mais espaço, será necessário criar uma nova array e, antes de se referir a ela, copie os elementos da array velha

- Declarando Arrays, utilizando o operador "new":
	dataType[] arrayName = new dataType[arraySize];
	
	int meuArray = new int[7];

- Declarando Arrays, já com valores:
	dataType[] arrayName = {value(), value1, ..., valueN};
	
	int[] meuArray = {12,32,54};

- Para alterar o valor de um elemento específico, coloque o índice desse elemento:
	meuArray[0] = 50;

- Comprimento do Array: Para descobrir quantos elementos um array possui, use a propriedade "length". Exemplo:

	meuArray.length;

- Para percorrer um array, devemos usar um laço de repetição (for, for each, etc);

- Arrays multidimensionais: Um array multidimensional é um array contendo um ou mais arrays internos

- exemplo de array multidimensional: int[][] meuArrayMulti = {{},{}}; // meuArrayMult é um array com dois arrays como os seus elementos

- Para percorrer um array multidimensional, nós usamos dois laços de repetição, na aula optamos pelo laço for;

- Se colocarmos somente o array, dentro de um System.out, por exemplo, será exibido o endereço de alocação de memória do array;

- [] = colchete;

- {} = chave;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Aprenda o funcionamento de Exceções em Java

- Exceptions: Exceções são todos os erros que ocorrem durante o processamento de um método que podem ser esperados ou não esperados. Como o termo já diz "Exceptions" são exceções. Falhas que não devem ocorrer rotineiramente no fluxo do sistema;	

- Exemplo de tratamento de exceção:
	public static void metodo() {
		try{
			new java.io.FileInputStream("arquivo.txt");
		} catch (java.io.FileNotFoundException e) {
			System.out.println("Não foi possível abrir o arquivo para leitura");
		}
	} 

- É uma boa prática, criar uma/s exceção/ões em cada método da aplicação, pois assim conseguimos observar onde os erros estão estourando, para assim resolvê-los;

- Geralmente, quando eu não tenho ideia, de que tipo de exceção pode ser estourada, eu uso a classe "Exception" (que herda da classe Throwable), que trata as execeções de formas mais genéricas, agora se eu souber o tipo de excessão que pode ser estourada, eu uso um tipo especifico de classem, para aquela exception, como o "NullPointerException" por exemplo;

- Exercício Final: Leituras Recomendadas (ler sobre exceções, no site da oracle) e aprofundamento sobre exceções;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Exceções esperadas e não esperadas

- Checked Exceptions: São exceções esperadas, cujo fluxo ou método de um sistema foi preparado para receber. Um bom exemplo é uma exceção de negócio, onde se deseja informar um erro caso a exceção esperada ocorra;

- Exemplo de checked exception:
	try{
		PreparedStatement stmt = con.prepareStatement(query);
		//...
	}catch (SQLException e) {
		throw new AcessoADadosException("Problema na criação do Statement", e);
	}

- Unchecked Exceptions: São exceções não esperadas para o fluxo ou método de um sistema, um bom exemplo é a famosa NullPointerException que ocorre quando se tenta acessar uma referência de memória vázia, ou recuperar uma instância que não existe, dentre outros motivos;

- Exemplo de unchecheck exception:
	try {
		CarroVo carro = new CarroVo();
		carro.getPlaca();
	} catch (IntegrationException e) {
		throw new BusinessException("Erro na criação do objeto", e);
	}

- Bloco Try catch: O bloco try catch é utilizado quando no processo que será executado dentro de um método é esperado um erro, então cria-se um bloco "protegido" onde qualquer erro que ocorra dentro do trecho "try" é direcionado para o trecho "catch" e sofrerá o devido tratamento de erro;

- Exemplo de bloco try catch:

	try {
		CarroVo carro = new CarroVo();
		carro.getPlaca();
	} catch (IntegrationException e) {
		throw new BusinessException("Erro na criação do objeto", e);
	}

- Exercício Final: Criar códigos com exceções que devem ser tratadas e não tratadas;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Aula: Conheça finally e throw 

- Finally: O finally é um bloco de código que pode ou não ser utilizado junto ao try catch, este trecho de código sempre será executado independente se ocorrer ou não dentro do fluxo onde existe o try catch. Normalmente, o finally, é usado para liberar recursos ou para dar continuidade em um fluxo que deve ocorrer independente de erro;

- O finally, é opcional;

- Exemplo de bloco finally:

	try {
		PreparedStatement stmt = con.prepareStatement(query);
		//..	
	} catch (SQLException e) {
		throw new AcessoADadosException("Problema na criação do Statement", e);
	} finally {
		stmt.close();
	}

- Throw e Throws:

	Throws: É a assinatura do método que será retornado caso ocorra erro para o método que fez a chamada, dentro de um fluxo encadeado

	Throw: É usado para lançar a exceção desejada, juntamente com a mensagem de erro, para o método que fez a chamada

-  Exemplo de throw e throws:

	public String recuperarIdUsuario(String query) throws AcessoADadosException {
		try{
			PreparedStatement stmt = con.prepareStatement(query);
			//...
		}catch (SQLException e) {
			throw new AcessoADadosException("Problema na criação do Statement", e);
		} finally {
			stmt.close();
		}
	}

- Throws é a informação, do erro esperado, indicada na assinatura de um método;

- Exercício Final: Criar métodos encadeados que definam o uso das exceções;